{
    "docs": [
        {
            "location": "/", 
            "text": "Advanded RecyclerView\n is an extension library of the \nRecyclerView\n.\n\n\nDemo app\n#\n\n\n\n\nPhirosophies\n#\n\n\n\n\nNever inherit \nRecyclerView\n class\n\n\n\ud83d\udc49 \n Reduces library conflictions, easy to integrate with existing code\n\n\n\n\n\n\nImplement each features ass separated modules\n\n\n\ud83d\udc49 \n Pick features only what you need\n\n\n\n\n\n\nPrimitive API set rather than user-friendly huge API sets\n\n\n\ud83d\udc49 \n Looks difficult at a glance, but gives great flexibility like original \nRecyclerView\n\n\n\n\n\n\n\n\nFeatures\n#\n\n\n\n\nSwipe\n\n\nSwipe dismiss and swipe pinning operation. (like Google's Inbox app)\n\n\n\n\n\n\nDrag and Drop\n\n\nSmooth item reordering with linear list (\nLinearLayoutManager\n). It behaves like the playlist of Google's Play Music app.\n\n\nAlso drag \n drop work with \nGridLayoutManager\n and \nStaggeredGridLayoutManager\n.\n\n\n\n\n\n\nExpand\n\n\nA list with collapsible groups and its children. This feature is port of the \nExpandableListView\n of Android framework.\n\n\n\n\n\n\nWrapper adapter\n\n\nInject additional functionalities to \nRecyclerView.Adapter\n by using the \nDecorator patten\n  (Header, Footer, Section, Combining multiple adapters, etc...)\n\n\n\n\n\n\nMisc.\n\n\nAll swipe, drag and drop, expand and wrapper adapter features work together!\n\n\nAn \nItemAnimator\n, it behaves exact the same as the default \nSimpleItemAnimator\n, but its code is refactored. More easy to customize!\n\n\nSome \nItemDecoration\ns. Adding drop shadows to each items, drawing separators.", 
            "title": "Home"
        }, 
        {
            "location": "/#demo-app", 
            "text": "", 
            "title": "Demo app"
        }, 
        {
            "location": "/#phirosophies", 
            "text": "Never inherit  RecyclerView  class  \ud83d\udc49   Reduces library conflictions, easy to integrate with existing code    Implement each features ass separated modules  \ud83d\udc49   Pick features only what you need    Primitive API set rather than user-friendly huge API sets  \ud83d\udc49   Looks difficult at a glance, but gives great flexibility like original  RecyclerView", 
            "title": "Phirosophies"
        }, 
        {
            "location": "/#features", 
            "text": "Swipe  Swipe dismiss and swipe pinning operation. (like Google's Inbox app)    Drag and Drop  Smooth item reordering with linear list ( LinearLayoutManager ). It behaves like the playlist of Google's Play Music app.  Also drag   drop work with  GridLayoutManager  and  StaggeredGridLayoutManager .    Expand  A list with collapsible groups and its children. This feature is port of the  ExpandableListView  of Android framework.    Wrapper adapter  Inject additional functionalities to  RecyclerView.Adapter  by using the  Decorator patten   (Header, Footer, Section, Combining multiple adapters, etc...)    Misc.  All swipe, drag and drop, expand and wrapper adapter features work together!  An  ItemAnimator , it behaves exact the same as the default  SimpleItemAnimator , but its code is refactored. More easy to customize!  Some  ItemDecoration s. Adding drop shadows to each items, drawing separators.", 
            "title": "Features"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Installation\n#\n\n\nAdd the following lines of code into your \nbuild.gradle\n.\n\n\ndependencies {\n    compile ('com.h6ah4i.android.widget.advrecyclerview:advrecyclerview:[VERSION_CODES_GOES_HERE]@aar'){\n        transitive=true\n    }\n}\n\n\n\n\nNOTE:\n\nThis library is served on \njCenter\n. If the above gradle setting not getting work, try adding the following lines.\n\n\nrepositories {\n    jcenter()\n}\n\n\n\n\nWhat's next?\n#\n\n\nFirst, I recommend you to learn about plain \nRecyclerView\n. Basic knowledges about \nRecyclerView\n is required before using this library. The following tutorial is good for starting point;\n\n\n\n\nCreating Lists and Cards | Android Developers - Training\n\n\n\n\nIf you've already know well about plain \nRecyclerView\n, proceed to each sections written about what you want to use:\n\n\n\n\nWrapper Adapter\n\n\nComposedAdapter\n\n\nHeaders \n Footers\n\n\nInsertion \n Filtering\n\n\n\n\n\n\nDrag \n Drop\n\n\nSwipeable\n\n\nExpandable\n\n\n\n\nOther references\n#\n\n\n\n\n\n\nDemo app code\n\n\n\n\nInstall the demo app from Google Play\n\n\nCheck the demo app code on GitHub\n\n\n\n\n\n\n\n\nOfficial RecyclerView reference\n\n\n\n\nCreating Lists and Cards --- Android Developers - Training\n\n\nRecyclerView --- Android Developers - Reference\n\n\n\n\n\n\n\n\nCheck the Issues page of Advanced RecyclerView\n\n\n\n\nIssues - Advanced RecyclerView --- GitHub\n\n\n\n\n\n\n\n\nJavadoc\n\n\n\n\nJavadoc - Advanced RecyclerView", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#installation", 
            "text": "Add the following lines of code into your  build.gradle .  dependencies {\n    compile ('com.h6ah4i.android.widget.advrecyclerview:advrecyclerview:[VERSION_CODES_GOES_HERE]@aar'){\n        transitive=true\n    }\n}  NOTE: \nThis library is served on  jCenter . If the above gradle setting not getting work, try adding the following lines.  repositories {\n    jcenter()\n}", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#whats-next", 
            "text": "First, I recommend you to learn about plain  RecyclerView . Basic knowledges about  RecyclerView  is required before using this library. The following tutorial is good for starting point;   Creating Lists and Cards | Android Developers - Training   If you've already know well about plain  RecyclerView , proceed to each sections written about what you want to use:   Wrapper Adapter  ComposedAdapter  Headers   Footers  Insertion   Filtering    Drag   Drop  Swipeable  Expandable", 
            "title": "What's next?"
        }, 
        {
            "location": "/getting-started/#other-references", 
            "text": "Demo app code   Install the demo app from Google Play  Check the demo app code on GitHub     Official RecyclerView reference   Creating Lists and Cards --- Android Developers - Training  RecyclerView --- Android Developers - Reference     Check the Issues page of Advanced RecyclerView   Issues - Advanced RecyclerView --- GitHub     Javadoc   Javadoc - Advanced RecyclerView", 
            "title": "Other references"
        }, 
        {
            "location": "/wrapper-adapter/", 
            "text": "The \nWrapperAdapter\n is a wrapper of another adapter(s). This is a core mechanism of Advanced RecyclerView library. Drag \n Drop, Swipe, Expand, Headers and Footers, etc... major features of this library are using it. We can implement additional functionalities by using \nDecorator pattern\n through the mechanism.\n\n\n\n\nThe \nWrapperAdapter\n is an interface and it is indended to be combined with \nRecyclerView.Adapter\n. The most important role of \nWrapperAdapter\n is converting \nposition\n of items by using \nwrapPosition()\n and \nunwrapPosition()\n methods.\n\n\n\n\nSubclasses:\n\n\n\n\nComposedAdapter\n\n\nSimpleWrapperAdapter\n\n\nAbstractHeaderFooterWrapperAdapter", 
            "title": "Wrapper Adapter"
        }, 
        {
            "location": "/wrapper-adapter/composed-adapter/", 
            "text": "Item position handling\n\n\nItem ID and ViewType handling\n\n\nItemIdComposer\n\n\nItemViewTypeComposer\n\n\n\n\n\n\nHow to migrate WRAPPED adapter?\n\n\nIf using Adapter.getAdaperPosition() / Adapter.getLayoutPosition())\n\n\nIf using ViewHolder.getItemViewType()\n\n\nIf using ViewHolder.getItemId()\n\n\nIf your adapter overrides optional methods of RecyclerView.Adapter\n\n\n\n\n\n\n\n\n\n\n\n\nThe \nComposedAdapter\n is an adapter which aggregates multiple adapters into one.\n\n\n\n\ndataSet = new DataSet();\n\ncomposedAdapter.addAdapter(new AdapterA(new DataSet()));\ncomposedAdapter.addAdapter(new AdapterB(new DataSet()));\ncomposedAdapter.addAdapter(new AdapterC(new DataSet()));\n\n\n\n\n\n\nMethods\n\n\n\n\nComposedChildAdapterTag ComposedAdapter.addAdapter(RecyclerView.Adapter adapter)\n\n\nComposedChildAdapterTag ComposedAdapter.addAdapter(RecyclerView.Adapter adapter, int position)\n\n\nboolean ComposedAdapter.addAdapter(ComposedChildAdapterTag tag)\n\n\n\n\n\n\nThe \nComposedAdapter\n can hold the same child adapter instance multiple times like this;\n\n\n\n\ndataSet = new DataSet();\n\nadapterA = new AdapterA(dataSet);\ncomposedAdapter.addAdapter(adapterA);\ncomposedAdapter.addAdapter(adapterA);\n\nadapterA2 = new AdapterA(dataSet);\ncomposedAdapter.addAdapter(adapterA2);\n\n\n\n\nItem position handling\n#\n\n\nThe \nComposedAdapter\n calls each child adapters as \nsegment\n, also child adapter's local item position are called as \noffset\n.\n\n\n\n\n\n\nMethods\n\n\n\n\nint ComposedAdapter.getSegment(ComposedChildAdapterTag tag)\n\n\nlong ComposedAdapter.getSegmentedPosition(int flatPosition)\n\n\nint ComposedAdapter.extractSegmentPart(long segmentedPosition)\n\n\nint ComposedAdapter.extractSegmentOffsetPart(long segmentedPosition)\n\n\n\n\n\n\nItem ID and ViewType handling\n#\n\n\nWhen merging adapters, we must take care about item IDs. They have to be unique in entire the dataset, but the problem is child datasets may contains the duplicated IDs. The \nItemIdComposer\n is used to manage this problem.\n\n\nItemIdComposer\n#\n\n\nThis utility class provides several static methods to handle the \npacked\n item ID value.\n\n\nItem IDs are expressed by 64 bits length integer in RecyclerView, so it can be embed multiple information by using bit operation technique. \nItemIdComposer\n divides 64 bits into four chunks; \nview type segment\n, \ngroup ID\n, \nchild ID\n and \nreserved bit\n.\n\n\n\n\n\n\n\n\nBits\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\nbit 63\n\n\nReserved\n\n\n\n\n\n\nbit 62-56\n\n\nView type segment\n\n\n\n\n\n\nbit 55-28\n\n\nGroup ID\n\n\n\n\n\n\nbit 27-0\n\n\nChild ID\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\nlong ItemIdComposer.composeSegment(int segment, long wrappedId)\n\n\nint ItemIdComposer.extractSegmentPart(long composedId)\n\n\nlong ItemIdComposer.extractExpandableGroupIdPart(long composedId)\n\n\nlong ItemIdComposer.extractExpandableChildIdPart(long composedId)\n\n\nlong ItemIdComposer.extractWrappedIdPart(long composedId)\n\n\nboolean ItemIdComposer.isExpandableGroup(long composedId)\n\n\nlong ItemIdComposer.composeExpandableChildId(long groupId, long childId)\n\n\nlong ItemIdComposer.composeExpandableGroupId(long groupId)\n\n\n\n\n\n\nItemViewTypeComposer\n#\n\n\nItem view type has similar problem like item ID. The \nItemViewTypeCompser\n manages packed item view type value that \nItemIdComposer\n doing it for item ID.\n\n\nItem view types are expressed by 32 bits integer in RecyclerView, and \nItemViewTypeCompser\n divides it into three chunks; \nexpandable group flag\n, \nview type segment\n and \nwrapped view type code\n.\n\n\n\n\n\n\n\n\nBits\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\nbit 31\n\n\nExpandable group flag  (1: expandable group / 0: normal item)\n\n\n\n\n\n\nbit 30-24\n\n\nView type segment\n\n\n\n\n\n\nbit 27-0\n\n\nWrapped view type code\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\nint ItemViewTypeComposer.composeSegment(int segment, int wrappedViewType)\n\n\nint ItemViewTypeComposer.extractSegmentPart(int composedViewType)\n\n\nint ItemViewTypeComposer.extractWrappedViewTypePart(int composedViewType)\n\n\nboolean ItemViewTypeComposer.isExpandableGroup(int composedViewType)\n\n\n\n\n\n\nHow to migrate \nWRAPPED\n adapter?\n#\n\n\nNeed to tweak several thing in your adapter implemtation because wrapper adapter modifies \nitem position\n, \nitem ID\n and \nitem view type\n.\n\n\nIf using Adapter.getAdaperPosition() / Adapter.getLayoutPosition())\n#\n\n\nUse `WrapperAdapterUtils.\n\n\n@Overfides\nvoid onClick(View v) {\n    RecyclerView rv = RecyclerViewAdapterUtils.getParentRecyclerView(v);\n    RecyclerView.ViewHolder vh = rv.findContainingViewHolder(v);\n\n    int rootPosition = vh.getAdapterPosition();\n    if (rootPosition == RecyclerView.NO_POSITION) {\n        return;\n    }\n\n    // need to determine adapter local position like this:\n    RecyclerView.Adapter rootAdapter = rv.getAdapter();\n    int localPosition = WrapperAdapterUtils.unwrapPosition(rootAdapter, this, rootPosition);\n\n    Item item = mItems.get(localPosition);\n    ...\n}\n\n\n\n\nIf using ViewHolder.getItemViewType()\n#\n\n\nUse \nItemViewTypeComposer.extractWrappedViewTypePart()\n.\n\n\n@Overfides\nvoid onClick(View v) {\n    RecyclerView.ViewHolder vh = recyclerView.findContainingViewHolder(v);\n\n    int rawViewType = vh.getItemViewType();\n    int viewType = ItemIdComposer.extractWrappedIdPart(rawViewType);\n\n    // use \nviewType\n here to determine which type of item is clicked\n    ...\n}\n\n\n\n\nIf using ViewHolder.getItemId()\n#\n\n\nUse \nItemIdComposer.extractWrappedIdPart()\n.\n\n\n@Overfides\nvoid onClick(View v) {\n    RecyclerView.ViewHolder vh = recyclerView.findContainingViewHolder(v);\n\n    long rawId = vh.getItemId();\n    long id = ItemIdComposer.extractWrappedIdPart(rawId);\n\n    // use \nid\n here to determine which item is clicked\n    ...\n}\n\n\n\n\nIf your adapter overrides optional methods of RecyclerView.Adapter\n#\n\n\nImplement \nWrappedAdapter\n interface and use the \nviewType\n parameter instead of \nViewHolder.getitemViewType()\n, if your adapter overrides these methods listed below.\n\n\n\n\nonViewAttachedToWindow()\n\n\nonViewDetachedFromWindow()\n\n\nonViewRecycled()\n\n\nonFailedToRecycleView()\n\n\n\n\nclass MyInnerAdapter\nVH\n implements WrappedAdapter\nVH\n {\n    // the following four methods are provided by WrappedAdapter interface\n    @Overrides\n    void onViewAttachedToWindow(VH holder, int viewType) {\n    }\n\n    @Overrides\n    void onViewDetachedFromWindow(VH holder, int viewType) {\n    }\n\n    @Overrides\n    void onViewRecycled(VH holder, int viewType) {\n    }\n\n    @Overrides\n    boolean onFailedToRecycleView(VH holder, int viewType) {\n    }\n\n    // proxy to WrappedAdapter's methods\n    @Overrides\n    void onViewAttachedToWindow(VH holder) {\n        onViewAttachedToWindow(holder, holder.getItemViewType());\n    }\n\n    @Overrides\n    void onViewDetachedFromWindow(VH holder, int viewType) {\n        onViewDetachedFromWindow(holder, holder.getItemViewType());\n    }\n\n    @Overrides\n    void onViewRecycled(VH holder, int viewType) {\n        onViewRecycled(holder, holder.getItemViewType());\n    }\n\n    @Overrides\n    boolean onFailedToRecycleView(VH holder, int viewType) {\n        onFailedToRecycleView(holder, holder.getItemViewType());\n    }\n}", 
            "title": "ComposedAdapter"
        }, 
        {
            "location": "/wrapper-adapter/composed-adapter/#item-position-handling", 
            "text": "The  ComposedAdapter  calls each child adapters as  segment , also child adapter's local item position are called as  offset .    Methods   int ComposedAdapter.getSegment(ComposedChildAdapterTag tag)  long ComposedAdapter.getSegmentedPosition(int flatPosition)  int ComposedAdapter.extractSegmentPart(long segmentedPosition)  int ComposedAdapter.extractSegmentOffsetPart(long segmentedPosition)", 
            "title": "Item position handling"
        }, 
        {
            "location": "/wrapper-adapter/composed-adapter/#item-id-and-viewtype-handling", 
            "text": "When merging adapters, we must take care about item IDs. They have to be unique in entire the dataset, but the problem is child datasets may contains the duplicated IDs. The  ItemIdComposer  is used to manage this problem.", 
            "title": "Item ID and ViewType handling"
        }, 
        {
            "location": "/wrapper-adapter/composed-adapter/#itemidcomposer", 
            "text": "This utility class provides several static methods to handle the  packed  item ID value.  Item IDs are expressed by 64 bits length integer in RecyclerView, so it can be embed multiple information by using bit operation technique.  ItemIdComposer  divides 64 bits into four chunks;  view type segment ,  group ID ,  child ID  and  reserved bit .     Bits  Usage      bit 63  Reserved    bit 62-56  View type segment    bit 55-28  Group ID    bit 27-0  Child ID      Methods   long ItemIdComposer.composeSegment(int segment, long wrappedId)  int ItemIdComposer.extractSegmentPart(long composedId)  long ItemIdComposer.extractExpandableGroupIdPart(long composedId)  long ItemIdComposer.extractExpandableChildIdPart(long composedId)  long ItemIdComposer.extractWrappedIdPart(long composedId)  boolean ItemIdComposer.isExpandableGroup(long composedId)  long ItemIdComposer.composeExpandableChildId(long groupId, long childId)  long ItemIdComposer.composeExpandableGroupId(long groupId)", 
            "title": "ItemIdComposer"
        }, 
        {
            "location": "/wrapper-adapter/composed-adapter/#itemviewtypecomposer", 
            "text": "Item view type has similar problem like item ID. The  ItemViewTypeCompser  manages packed item view type value that  ItemIdComposer  doing it for item ID.  Item view types are expressed by 32 bits integer in RecyclerView, and  ItemViewTypeCompser  divides it into three chunks;  expandable group flag ,  view type segment  and  wrapped view type code .     Bits  Usage      bit 31  Expandable group flag  (1: expandable group / 0: normal item)    bit 30-24  View type segment    bit 27-0  Wrapped view type code      Methods   int ItemViewTypeComposer.composeSegment(int segment, int wrappedViewType)  int ItemViewTypeComposer.extractSegmentPart(int composedViewType)  int ItemViewTypeComposer.extractWrappedViewTypePart(int composedViewType)  boolean ItemViewTypeComposer.isExpandableGroup(int composedViewType)", 
            "title": "ItemViewTypeComposer"
        }, 
        {
            "location": "/wrapper-adapter/composed-adapter/#how-to-migrate-wrapped-adapter", 
            "text": "Need to tweak several thing in your adapter implemtation because wrapper adapter modifies  item position ,  item ID  and  item view type .", 
            "title": "How to migrate WRAPPED adapter?"
        }, 
        {
            "location": "/wrapper-adapter/composed-adapter/#if-using-adaptergetadaperposition-adaptergetlayoutposition", 
            "text": "Use `WrapperAdapterUtils.  @Overfides\nvoid onClick(View v) {\n    RecyclerView rv = RecyclerViewAdapterUtils.getParentRecyclerView(v);\n    RecyclerView.ViewHolder vh = rv.findContainingViewHolder(v);\n\n    int rootPosition = vh.getAdapterPosition();\n    if (rootPosition == RecyclerView.NO_POSITION) {\n        return;\n    }\n\n    // need to determine adapter local position like this:\n    RecyclerView.Adapter rootAdapter = rv.getAdapter();\n    int localPosition = WrapperAdapterUtils.unwrapPosition(rootAdapter, this, rootPosition);\n\n    Item item = mItems.get(localPosition);\n    ...\n}", 
            "title": "If using Adapter.getAdaperPosition() / Adapter.getLayoutPosition())"
        }, 
        {
            "location": "/wrapper-adapter/composed-adapter/#if-using-viewholdergetitemviewtype", 
            "text": "Use  ItemViewTypeComposer.extractWrappedViewTypePart() .  @Overfides\nvoid onClick(View v) {\n    RecyclerView.ViewHolder vh = recyclerView.findContainingViewHolder(v);\n\n    int rawViewType = vh.getItemViewType();\n    int viewType = ItemIdComposer.extractWrappedIdPart(rawViewType);\n\n    // use  viewType  here to determine which type of item is clicked\n    ...\n}", 
            "title": "If using ViewHolder.getItemViewType()"
        }, 
        {
            "location": "/wrapper-adapter/composed-adapter/#if-using-viewholdergetitemid", 
            "text": "Use  ItemIdComposer.extractWrappedIdPart() .  @Overfides\nvoid onClick(View v) {\n    RecyclerView.ViewHolder vh = recyclerView.findContainingViewHolder(v);\n\n    long rawId = vh.getItemId();\n    long id = ItemIdComposer.extractWrappedIdPart(rawId);\n\n    // use  id  here to determine which item is clicked\n    ...\n}", 
            "title": "If using ViewHolder.getItemId()"
        }, 
        {
            "location": "/wrapper-adapter/composed-adapter/#if-your-adapter-overrides-optional-methods-of-recyclerviewadapter", 
            "text": "Implement  WrappedAdapter  interface and use the  viewType  parameter instead of  ViewHolder.getitemViewType() , if your adapter overrides these methods listed below.   onViewAttachedToWindow()  onViewDetachedFromWindow()  onViewRecycled()  onFailedToRecycleView()   class MyInnerAdapter VH  implements WrappedAdapter VH  {\n    // the following four methods are provided by WrappedAdapter interface\n    @Overrides\n    void onViewAttachedToWindow(VH holder, int viewType) {\n    }\n\n    @Overrides\n    void onViewDetachedFromWindow(VH holder, int viewType) {\n    }\n\n    @Overrides\n    void onViewRecycled(VH holder, int viewType) {\n    }\n\n    @Overrides\n    boolean onFailedToRecycleView(VH holder, int viewType) {\n    }\n\n    // proxy to WrappedAdapter's methods\n    @Overrides\n    void onViewAttachedToWindow(VH holder) {\n        onViewAttachedToWindow(holder, holder.getItemViewType());\n    }\n\n    @Overrides\n    void onViewDetachedFromWindow(VH holder, int viewType) {\n        onViewDetachedFromWindow(holder, holder.getItemViewType());\n    }\n\n    @Overrides\n    void onViewRecycled(VH holder, int viewType) {\n        onViewRecycled(holder, holder.getItemViewType());\n    }\n\n    @Overrides\n    boolean onFailedToRecycleView(VH holder, int viewType) {\n        onFailedToRecycleView(holder, holder.getItemViewType());\n    }\n}", 
            "title": "If your adapter overrides optional methods of RecyclerView.Adapter"
        }, 
        {
            "location": "/wrapper-adapter/headers-footers/", 
            "text": "When creating headers \n footers, the \nAbstractHeaderFooterWrapperAdapter\n can be a good alternative to the \nComposedAdapter\n. This class provides simple way to creating a wrapper crass for headers \n footers by implementing small number of methods.\n\n\nQuick quide\n#\n\n\nUsage\n#\n\n\nMyAdapter adapter = new MyAdapter();\nMyHeadFootAdapter wrappedAdapter = new MyHeadFootAdapter(adapter);\n\nrecyclerView.setAdapter(wrappedAdapter);\n\n\n\n\nImplementation of headers \n footers wrapper adapter\n#\n\n\nclass MyHeadFootAdapter \n    extends AbstractHeaderFooterWrapperAdapter\nMyHeadFootAdapter.HeaderVH, MyHeadFootAdapter.FooterVH\n\n{\n    static class HeaderVH extends RecylerView.ViewHolder { ... }\n    static class FooterVH extends RecylerView.ViewHolder { ... }\n\n    public MyHeadFootAdapter(RecyclerView.Adapter adapter) {\n        super.this(adapter);\n    }\n\n    @Override\n    public int getHeaderItemCount() {\n        return \nNUMBER OF HEADER ITEMS GOES HERE\n;\n    }\n\n    @Override\n    public int getFooterItemCount() {\n        return \nNUMBER OF FOOTER ITEMS GOES HERE\n;\n    }\n\n    @Override\n    public HeaderVH onCreateHeaderItemViewHolder(ViewGroup parent, int viewType) {\n        View v = ...;\n        return new HeaderVH(v);\n    }\n\n    @Override\n    public FooterVH onCreateFooterItemViewHolder(ViewGroup parent, int viewType) {\n        View v = ...;\n        return new FooterVH(v);\n    }\n\n    @Override\n    public void onBindHeaderItemViewHolder(HeaderVH holder, int localPosition) {\n        // bind data to header items views\n    }\n\n    @Override\n    public void onBindFooterItemViewHolder(FooterVH holder, int localPosition) {\n        // bind data to footer items views\n    }\n}\n\n\n\n\nClick event handling\n#\n\n\nThe \nAbstractHeaderFooterWrapperAdapter\n extends \nComposedAdapter\n so the same click event hadling approach is required.\n\n\nclass MyHeadFootAdapter \n    extends AbstractHeaderFooterWrapperAdapter\nMyHeadFootAdapter.HeaderVH, MyHeadFootAdapter.FooterVH\n\n    implements View.OnClickListener {\n\n    @Override\n    public HeaderVH onCreateHeaderItemViewHolder(ViewGroup parent, int viewType) {\n        View v = ...;\n        return new HeaderVH(v);\n    }\n\n    @Override\n    public void onClick(View v) {\n        RecyclerView rv = RecyclerViewAdapterUtils.getParentRecyclerView(v);\n        RecyclerView.ViewHolder vh = rv.findContainingViewHolder(v);\n\n        int rootPosition = vh.getAdapterPosition();\n        if (rootPosition == RecyclerView.NO_POSITION) {\n            return;\n        }\n\n        // need to determine adapter local position like this:\n        RecyclerView.Adapter rootAdapter = rv.getAdapter();\n        int localPosition = WrapperAdapterUtils.unwrapPosition(rootAdapter, this, rootPosition);\n\n        // get segment\n        long segmentedPosition = getSegmentedPosition(localPosition);\n        int segment = extractSegmentPart(segmentedPosition);\n        int offset = extractSegmentOffsetPart(segmentedPosition);\n\n        String message;\n\n        if (segment == SEGMENT_TYPE_HEADER) {\n            // Header item is clicked !\n        } else if (segment == SEGMENT_TYPE_FOOTER) {\n            // Footer item is clicked !\n        }\n    }\n}\n\n\n\n\nMultipe view type handling\n#\n\n\nJust same as \nComposedAdapter\n, so need to use \nItemViewTypeComposer.extractWrappedViewTypePart()\n when using view type.\n\n\n@Override\npublic int getHeaderItemViewType(int localPosition) {\n    return position % 2;\n}\n\n@Override\npublic void onBindHeaderItemViewHolder(HeaderViewHolder holder, int localPosition) {\n    int viewType = ItemViewTypeComposer.extractWrappedViewTypePart(holder.getItemViewType());\n\n    if (viewType == 0) {\n        ...\n    } else {\n        ...\n    }\n}", 
            "title": "Headers & Footers"
        }, 
        {
            "location": "/wrapper-adapter/headers-footers/#quick-quide", 
            "text": "", 
            "title": "Quick quide"
        }, 
        {
            "location": "/wrapper-adapter/headers-footers/#usage", 
            "text": "MyAdapter adapter = new MyAdapter();\nMyHeadFootAdapter wrappedAdapter = new MyHeadFootAdapter(adapter);\n\nrecyclerView.setAdapter(wrappedAdapter);", 
            "title": "Usage"
        }, 
        {
            "location": "/wrapper-adapter/headers-footers/#implementation-of-headers-footers-wrapper-adapter", 
            "text": "class MyHeadFootAdapter \n    extends AbstractHeaderFooterWrapperAdapter MyHeadFootAdapter.HeaderVH, MyHeadFootAdapter.FooterVH \n{\n    static class HeaderVH extends RecylerView.ViewHolder { ... }\n    static class FooterVH extends RecylerView.ViewHolder { ... }\n\n    public MyHeadFootAdapter(RecyclerView.Adapter adapter) {\n        super.this(adapter);\n    }\n\n    @Override\n    public int getHeaderItemCount() {\n        return  NUMBER OF HEADER ITEMS GOES HERE ;\n    }\n\n    @Override\n    public int getFooterItemCount() {\n        return  NUMBER OF FOOTER ITEMS GOES HERE ;\n    }\n\n    @Override\n    public HeaderVH onCreateHeaderItemViewHolder(ViewGroup parent, int viewType) {\n        View v = ...;\n        return new HeaderVH(v);\n    }\n\n    @Override\n    public FooterVH onCreateFooterItemViewHolder(ViewGroup parent, int viewType) {\n        View v = ...;\n        return new FooterVH(v);\n    }\n\n    @Override\n    public void onBindHeaderItemViewHolder(HeaderVH holder, int localPosition) {\n        // bind data to header items views\n    }\n\n    @Override\n    public void onBindFooterItemViewHolder(FooterVH holder, int localPosition) {\n        // bind data to footer items views\n    }\n}", 
            "title": "Implementation of headers &amp; footers wrapper adapter"
        }, 
        {
            "location": "/wrapper-adapter/headers-footers/#click-event-handling", 
            "text": "The  AbstractHeaderFooterWrapperAdapter  extends  ComposedAdapter  so the same click event hadling approach is required.  class MyHeadFootAdapter \n    extends AbstractHeaderFooterWrapperAdapter MyHeadFootAdapter.HeaderVH, MyHeadFootAdapter.FooterVH \n    implements View.OnClickListener {\n\n    @Override\n    public HeaderVH onCreateHeaderItemViewHolder(ViewGroup parent, int viewType) {\n        View v = ...;\n        return new HeaderVH(v);\n    }\n\n    @Override\n    public void onClick(View v) {\n        RecyclerView rv = RecyclerViewAdapterUtils.getParentRecyclerView(v);\n        RecyclerView.ViewHolder vh = rv.findContainingViewHolder(v);\n\n        int rootPosition = vh.getAdapterPosition();\n        if (rootPosition == RecyclerView.NO_POSITION) {\n            return;\n        }\n\n        // need to determine adapter local position like this:\n        RecyclerView.Adapter rootAdapter = rv.getAdapter();\n        int localPosition = WrapperAdapterUtils.unwrapPosition(rootAdapter, this, rootPosition);\n\n        // get segment\n        long segmentedPosition = getSegmentedPosition(localPosition);\n        int segment = extractSegmentPart(segmentedPosition);\n        int offset = extractSegmentOffsetPart(segmentedPosition);\n\n        String message;\n\n        if (segment == SEGMENT_TYPE_HEADER) {\n            // Header item is clicked !\n        } else if (segment == SEGMENT_TYPE_FOOTER) {\n            // Footer item is clicked !\n        }\n    }\n}", 
            "title": "Click event handling"
        }, 
        {
            "location": "/wrapper-adapter/headers-footers/#multipe-view-type-handling", 
            "text": "Just same as  ComposedAdapter , so need to use  ItemViewTypeComposer.extractWrappedViewTypePart()  when using view type.  @Override\npublic int getHeaderItemViewType(int localPosition) {\n    return position % 2;\n}\n\n@Override\npublic void onBindHeaderItemViewHolder(HeaderViewHolder holder, int localPosition) {\n    int viewType = ItemViewTypeComposer.extractWrappedViewTypePart(holder.getItemViewType());\n\n    if (viewType == 0) {\n        ...\n    } else {\n        ...\n    }\n}", 
            "title": "Multipe view type handling"
        }, 
        {
            "location": "/wrapper-adapter/insertion-filtering/", 
            "text": "Insertion\n#\n\n\nFiltering\n#", 
            "title": "Insertion & Filtering"
        }, 
        {
            "location": "/wrapper-adapter/insertion-filtering/#insertion", 
            "text": "", 
            "title": "Insertion"
        }, 
        {
            "location": "/wrapper-adapter/insertion-filtering/#filtering", 
            "text": "", 
            "title": "Filtering"
        }, 
        {
            "location": "/draggable/", 
            "text": "", 
            "title": "Drag & Drop"
        }, 
        {
            "location": "/swipeable/", 
            "text": "1. Make the adapter supports stable ID\n#\n\n\nThis step is very important. If adapter does not return stable \n unique ID, it will cause weird behaviors (wrong animation, NPE, etc...)\n\n\nclass MyAdapter extends RecyclerView.Adapter\nMyAdapter.MyViewHolder\n {\n    MyAdapter() {\n        setHasStableIds(true);\n    }\n\n    @Override\n    public long getItemId(int position) {\n        // requires static value, it means need to keep the same value\n        // even if the item position has been changed.\n        return mItems.get(position).getId();\n    }\n}\n\n\n\n\n2. Implement the \nSwipeableItemAdapter\n interface\n#\n\n\nclass MyAdapter extends RecyclerView.Adapter\nMyAdapter.MyViewHolder\n {\n    ...\n    static class MyViewHolder extends RecyclerView.ViewHolder {\n        ...\n    }\n}\n\n\n\n\n:arrow_down: :arrow_down: :arrow_down:\n\n\nclass MyAdapter extends RecyclerView.Adapter\nMyAdapter.MyViewHolder\n \n        extends RecyclerView.Adapter\nMyAdapter.MyViewHolder\n\n        implements SwipeableItemAdapter\nMyAdapter.MyViewHolder\n {\n\n    // NOTE: Make accessible with short name\n    private interface Swipeable extends SwipeableItemConstants {\n    }\n\n    ...\n\n    @Override\n    public int onGetSwipeReactionType(MyViewHolder holder, int position, int x, int y) {\n        // TODO implement here later\n        return Swipeable.REACTION_CAN_NOT_SWIPE_ANY;\n    }\n\n    @Override\n    public void onSetSwipeBackground(MyViewHolder holder, int position, int type) {\n        // TODO implement here later\n    }\n\n    @Override\n    public SwipeResultAction onSwipeItem(MyViewHolder holder, final int position, int result) {\n        // TODO implement here later\n        return new SwipeResultActionDefault();\n    }\n\n    static class MyViewHolder extends RecyclerView.ViewHolder {\n        ...\n    }\n}\n\n\n\n\n3. Extend the \nAbstractSwipeableItemViewHolder\n instead of the \nRecyclerView.ViewHolder\n#\n\n\nclass MyAdapter ... {\n    ...\n    static class MyViewHolder extends RecyclerView.ViewHolder {\n        ...\n\n        public MyViewHolder(View v) {\n            super(v);\n            ...\n        }\n\n        ...\n    }\n}\n\n\n\n\n:arrow_down: :arrow_down: :arrow_down:\n\n\nclass MyAdapter ... {\n    ...\n public static class MyViewHolder extends AbstractSwipeableItemViewHolder {\n\u3000\u3000\u3000\u3000\u3000...\n\n        public MyViewHolder(View v) {\n            super(v);\n            ...\n        }\n\n        @Override\n        public View getSwipeableContainerView() {\n            // TODO implement here later\n            return null;\n        }\n\n        ...\n    }\n}\n\n\n\n\n4. Modify layout file of item views\n#\n\n\nTextView\n    xmlns:android=\nhttp://schemas.android.com/apk/res/android\n\n    android:id=\n@android:id/text1\n\n    android:layout_width=\nmatch_parent\n\n    android:layout_height=\n56dp\n\n    android:gravity=\ncenter\n/\n\n\n\n\n:arrow_down: :arrow_down: :arrow_down: \n\n\nFrameLayout\n    xmlns:android=\nhttp://schemas.android.com/apk/res/android\n\n    android:layout_width=\nmatch_parent\n\n    android:layout_height=\n56dp\n\n\n    \nFrameLayout\n        android:id=\n@+id/container\n\n        android:layout_width=\nmatch_parent\n\n        android:layout_height=\nmatch_parent\n\n\n        \nTextView\n            android:id=\n@android:id/text1\n\n            android:layout_width=\nmatch_parent\n\n            android:layout_height=\n56dp\n\n            android:layout_gravity=\ntop|left\n\n            android:gravity=\ncenter\n/\n\n\n    \n/FrameLayout\n\n\n/FrameLayout\n\n\n\n\n5. Update ViewHolder\n#\n\n\nclass MyAdapter ... {\n    ...\n public static class MyViewHolder extends AbstractSwipeableItemViewHolder {\n        TextView mText;\n\n        public MyViewHolder(View v) {\n            super(v);\n            mText = (TextView) v;\n        }\n\n        @Override\n        public View getSwipeableContainerView() {\n            // TODO implement here later\n            return null;\n        }\n\n        ...\n    }\n}\n\n\n\n\n:arrow_down: :arrow_down: :arrow_down:\n\n\nclass MyAdapter ... {\n    ...\n public static class MyViewHolder extends AbstractSwipeableItemViewHolder {\n        TextView mTextView;\n        FrameLayout mContainer;\n\n        public MyViewHolder(View v) {\n            super(v);\n            mTextView = (TextView) v.findViewById(android.R.id.text1);\n            mContainer = (FrameLayout) v.findViewById(R.id.container);\n        }\n\n        @Override\n        public View getSwipeableContainerView() {\n            return mContainer;\n        }\n\n        ...\n    }\n}\n\n\n\n\n6. Update Adapter\n#\n\n\nclass MyAdapter ... {\n\n    ...\n\n    @Override\n    public int onGetSwipeReactionType(MyViewHolder holder, int position, int x, int y) {\n        ...\n    }\n\n    @Override\n    public void onSetSwipeBackground(MyViewHolder holder, int position, int type) {\n        ...\n    }\n\n    @Override\n    public SwipeResultAction onSwipeItem(MyViewHolder holder, int position, int result) {\n        ...\n    }\n\n    static class MyViewHolder ... {\n        ...\n    }\n}\n\n\n\n\n:arrow_down: :arrow_down: :arrow_down: \n\n\nclass MyAdapter ... {\n\n    ...\n\n    @Override\n    public int onGetSwipeReactionType(MyViewHolder holder, int position, int x, int y) {\n        // Make swipeable to LEFT direction\n        return Swipeable.REACTION_CAN_SWIPE_LEFT;\n    }\n\n    @Override\n    public void onSetSwipeBackground(MyViewHolder holder, int position, int type) {\n        // You can set background color to holder.itemView.\n\n        // The argument \ntype\n can be one of the followings;\n        // - Swipeable.DRAWABLE_SWIPE_NEUTRAL_BACKGROUND\n        // - Swipeable.DRAWABLE_SWIPE_LEFT_BACKGROUND\n        // (- Swipeable.DRAWABLE_SWIPE_UP_BACKGROUND)\n        // (- Swipeable.DRAWABLE_SWIPE_RIGHT_BACKGROUND)\n        // (- Swipeable.DRAWABLE_SWIPE_DOWN_BACKGROUND)\n    }\n\n    @Override\n    public SwipeResultAction onSwipeItem(MyViewHolder holder, int position, int result) {\n        // Return sub class of the SwipeResultAction.\n        // Base (abstract) classes are\n        // - SwipeResultActionDefault\n        // - SwipeResultActionMoveToSwipedDirection\n        // - SwipeResultActionRemoveItem\n\n        // The argument \nresult\n can be one of the followings;\n        // \n        // - Swipeable.RESULT_CANCELED\n        // - Swipeable.RESULT_SWIPED_LEFT\n        // (- Swipeable.RESULT_SWIPED_UP)\n        // (- Swipeable.RESULT_SWIPED_RIGHT)\n        // (- Swipeable.RESULT_SWIPED_DOWN)\n\n        if (result == Swipeable.RESULT_LEFT) {\n            return new SwipeResultActionMoveToSwipedDirection() {\n                // You can override these three methods\n                // - void onPerformAction()\n                // - void onSlideAnimationEnd()\n                // - void onCleanUp()\n            };\n        } else {\n            return new SwipeResultActionDefault();\n        }\n    }\n\n    static class MyViewHolder ... {\n        ...\n    }\n}\n\n\n\n\n7. Modify initialization of RecyclerView in Activity (or in Fragment)\n#\n\n\nvoid onCreate() {\n    ...\n\n    RecyclerView recyclerView = findViewById(R.id.recyclerView);\n    MyAdapter adapter = new MyAdapter();\n\n    recyclerView.setAdapter(adapter);\n    recyclerView.setLayoutManager(new LinearLayoutManager(this));\n}\n\n\n\n\n:arrow_down: :arrow_down: :arrow_down: \n\n\nvoid onCreate() {\n    ...\n\n    RecyclerView recyclerView = findViewById(R.id.recyclerView);\n    RecyclerViewSwipeManager swipeManager = new RecyclerViewSwipeManager();\n\n\n    MyAdapter adapter = new MyAdapter();\n    RecyclerView.Adapter wrappedAdapter = swipeManager.createWrappedAdapter(adapter);\n\n    recyclerView.setAdapter(wrappedAdapter);\n    recyclerView.setLayoutManager(new LinearLayoutManager(this));\n\n    swipeManager.attachRecyclerView(recyclerView);\n}\n\n\n\n\n8. Custom more and details of the implementation\n#\n\n\nPlease refer to \nthe example app implementation\n.", 
            "title": "Swipeable"
        }, 
        {
            "location": "/swipeable/#1-make-the-adapter-supports-stable-id", 
            "text": "This step is very important. If adapter does not return stable   unique ID, it will cause weird behaviors (wrong animation, NPE, etc...)  class MyAdapter extends RecyclerView.Adapter MyAdapter.MyViewHolder  {\n    MyAdapter() {\n        setHasStableIds(true);\n    }\n\n    @Override\n    public long getItemId(int position) {\n        // requires static value, it means need to keep the same value\n        // even if the item position has been changed.\n        return mItems.get(position).getId();\n    }\n}", 
            "title": "1. Make the adapter supports stable ID"
        }, 
        {
            "location": "/swipeable/#2-implement-the-swipeableitemadapter-interface", 
            "text": "class MyAdapter extends RecyclerView.Adapter MyAdapter.MyViewHolder  {\n    ...\n    static class MyViewHolder extends RecyclerView.ViewHolder {\n        ...\n    }\n}  :arrow_down: :arrow_down: :arrow_down:  class MyAdapter extends RecyclerView.Adapter MyAdapter.MyViewHolder  \n        extends RecyclerView.Adapter MyAdapter.MyViewHolder \n        implements SwipeableItemAdapter MyAdapter.MyViewHolder  {\n\n    // NOTE: Make accessible with short name\n    private interface Swipeable extends SwipeableItemConstants {\n    }\n\n    ...\n\n    @Override\n    public int onGetSwipeReactionType(MyViewHolder holder, int position, int x, int y) {\n        // TODO implement here later\n        return Swipeable.REACTION_CAN_NOT_SWIPE_ANY;\n    }\n\n    @Override\n    public void onSetSwipeBackground(MyViewHolder holder, int position, int type) {\n        // TODO implement here later\n    }\n\n    @Override\n    public SwipeResultAction onSwipeItem(MyViewHolder holder, final int position, int result) {\n        // TODO implement here later\n        return new SwipeResultActionDefault();\n    }\n\n    static class MyViewHolder extends RecyclerView.ViewHolder {\n        ...\n    }\n}", 
            "title": "2. Implement the SwipeableItemAdapter interface"
        }, 
        {
            "location": "/swipeable/#3-extend-the-abstractswipeableitemviewholder-instead-of-the-recyclerviewviewholder", 
            "text": "class MyAdapter ... {\n    ...\n    static class MyViewHolder extends RecyclerView.ViewHolder {\n        ...\n\n        public MyViewHolder(View v) {\n            super(v);\n            ...\n        }\n\n        ...\n    }\n}  :arrow_down: :arrow_down: :arrow_down:  class MyAdapter ... {\n    ...\n public static class MyViewHolder extends AbstractSwipeableItemViewHolder {\n\u3000\u3000\u3000\u3000\u3000...\n\n        public MyViewHolder(View v) {\n            super(v);\n            ...\n        }\n\n        @Override\n        public View getSwipeableContainerView() {\n            // TODO implement here later\n            return null;\n        }\n\n        ...\n    }\n}", 
            "title": "3. Extend the AbstractSwipeableItemViewHolder instead of the RecyclerView.ViewHolder"
        }, 
        {
            "location": "/swipeable/#4-modify-layout-file-of-item-views", 
            "text": "TextView\n    xmlns:android= http://schemas.android.com/apk/res/android \n    android:id= @android:id/text1 \n    android:layout_width= match_parent \n    android:layout_height= 56dp \n    android:gravity= center /  :arrow_down: :arrow_down: :arrow_down:   FrameLayout\n    xmlns:android= http://schemas.android.com/apk/res/android \n    android:layout_width= match_parent \n    android:layout_height= 56dp \n\n     FrameLayout\n        android:id= @+id/container \n        android:layout_width= match_parent \n        android:layout_height= match_parent \n\n         TextView\n            android:id= @android:id/text1 \n            android:layout_width= match_parent \n            android:layout_height= 56dp \n            android:layout_gravity= top|left \n            android:gravity= center / \n\n     /FrameLayout  /FrameLayout", 
            "title": "4. Modify layout file of item views"
        }, 
        {
            "location": "/swipeable/#5-update-viewholder", 
            "text": "class MyAdapter ... {\n    ...\n public static class MyViewHolder extends AbstractSwipeableItemViewHolder {\n        TextView mText;\n\n        public MyViewHolder(View v) {\n            super(v);\n            mText = (TextView) v;\n        }\n\n        @Override\n        public View getSwipeableContainerView() {\n            // TODO implement here later\n            return null;\n        }\n\n        ...\n    }\n}  :arrow_down: :arrow_down: :arrow_down:  class MyAdapter ... {\n    ...\n public static class MyViewHolder extends AbstractSwipeableItemViewHolder {\n        TextView mTextView;\n        FrameLayout mContainer;\n\n        public MyViewHolder(View v) {\n            super(v);\n            mTextView = (TextView) v.findViewById(android.R.id.text1);\n            mContainer = (FrameLayout) v.findViewById(R.id.container);\n        }\n\n        @Override\n        public View getSwipeableContainerView() {\n            return mContainer;\n        }\n\n        ...\n    }\n}", 
            "title": "5. Update ViewHolder"
        }, 
        {
            "location": "/swipeable/#6-update-adapter", 
            "text": "class MyAdapter ... {\n\n    ...\n\n    @Override\n    public int onGetSwipeReactionType(MyViewHolder holder, int position, int x, int y) {\n        ...\n    }\n\n    @Override\n    public void onSetSwipeBackground(MyViewHolder holder, int position, int type) {\n        ...\n    }\n\n    @Override\n    public SwipeResultAction onSwipeItem(MyViewHolder holder, int position, int result) {\n        ...\n    }\n\n    static class MyViewHolder ... {\n        ...\n    }\n}  :arrow_down: :arrow_down: :arrow_down:   class MyAdapter ... {\n\n    ...\n\n    @Override\n    public int onGetSwipeReactionType(MyViewHolder holder, int position, int x, int y) {\n        // Make swipeable to LEFT direction\n        return Swipeable.REACTION_CAN_SWIPE_LEFT;\n    }\n\n    @Override\n    public void onSetSwipeBackground(MyViewHolder holder, int position, int type) {\n        // You can set background color to holder.itemView.\n\n        // The argument  type  can be one of the followings;\n        // - Swipeable.DRAWABLE_SWIPE_NEUTRAL_BACKGROUND\n        // - Swipeable.DRAWABLE_SWIPE_LEFT_BACKGROUND\n        // (- Swipeable.DRAWABLE_SWIPE_UP_BACKGROUND)\n        // (- Swipeable.DRAWABLE_SWIPE_RIGHT_BACKGROUND)\n        // (- Swipeable.DRAWABLE_SWIPE_DOWN_BACKGROUND)\n    }\n\n    @Override\n    public SwipeResultAction onSwipeItem(MyViewHolder holder, int position, int result) {\n        // Return sub class of the SwipeResultAction.\n        // Base (abstract) classes are\n        // - SwipeResultActionDefault\n        // - SwipeResultActionMoveToSwipedDirection\n        // - SwipeResultActionRemoveItem\n\n        // The argument  result  can be one of the followings;\n        // \n        // - Swipeable.RESULT_CANCELED\n        // - Swipeable.RESULT_SWIPED_LEFT\n        // (- Swipeable.RESULT_SWIPED_UP)\n        // (- Swipeable.RESULT_SWIPED_RIGHT)\n        // (- Swipeable.RESULT_SWIPED_DOWN)\n\n        if (result == Swipeable.RESULT_LEFT) {\n            return new SwipeResultActionMoveToSwipedDirection() {\n                // You can override these three methods\n                // - void onPerformAction()\n                // - void onSlideAnimationEnd()\n                // - void onCleanUp()\n            };\n        } else {\n            return new SwipeResultActionDefault();\n        }\n    }\n\n    static class MyViewHolder ... {\n        ...\n    }\n}", 
            "title": "6. Update Adapter"
        }, 
        {
            "location": "/swipeable/#7-modify-initialization-of-recyclerview-in-activity-or-in-fragment", 
            "text": "void onCreate() {\n    ...\n\n    RecyclerView recyclerView = findViewById(R.id.recyclerView);\n    MyAdapter adapter = new MyAdapter();\n\n    recyclerView.setAdapter(adapter);\n    recyclerView.setLayoutManager(new LinearLayoutManager(this));\n}  :arrow_down: :arrow_down: :arrow_down:   void onCreate() {\n    ...\n\n    RecyclerView recyclerView = findViewById(R.id.recyclerView);\n    RecyclerViewSwipeManager swipeManager = new RecyclerViewSwipeManager();\n\n\n    MyAdapter adapter = new MyAdapter();\n    RecyclerView.Adapter wrappedAdapter = swipeManager.createWrappedAdapter(adapter);\n\n    recyclerView.setAdapter(wrappedAdapter);\n    recyclerView.setLayoutManager(new LinearLayoutManager(this));\n\n    swipeManager.attachRecyclerView(recyclerView);\n}", 
            "title": "7. Modify initialization of RecyclerView in Activity (or in Fragment)"
        }, 
        {
            "location": "/swipeable/#8-custom-more-and-details-of-the-implementation", 
            "text": "Please refer to  the example app implementation .", 
            "title": "8. Custom more and details of the implementation"
        }, 
        {
            "location": "/expandable/", 
            "text": "", 
            "title": "Expandable"
        }, 
        {
            "location": "/advanced-examples/", 
            "text": "Expandable + Draggable + Swipeable\n#", 
            "title": "Advanced Examples"
        }, 
        {
            "location": "/advanced-examples/#expandable-draggable-swipeable", 
            "text": "", 
            "title": "Expandable + Draggable + Swipeable"
        }, 
        {
            "location": "/faq/", 
            "text": "TODO", 
            "title": "FAQ"
        }, 
        {
            "location": "/license/", 
            "text": "Copyright (C) 2015 Haruki Hasegawa\n\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "License"
        }
    ]
}